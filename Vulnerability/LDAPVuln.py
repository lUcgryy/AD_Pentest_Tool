from Vulnerability.Vuln import Vuln_Base
from Util.writeHelper import *
from colorama import Fore, Style
from Enumeration.LDAPSession import *
from Enumeration.ACLs import *
import json
from datetime import datetime, timedelta

def get_message_prefix_by_type(type):
    if type == 'user':
        return 'user: '
    elif type == 'group':
        return 'group: '
    elif type == 'computer':
        return 'computer: '
    elif type == 'ou':
        return 'organizational Unit: '
    elif type == 'gpo':
        return 'Group Policy Object: '
    elif type == 'domain':
        return 'domain: '
    else:
        return ''

def red_message(message):
    return Fore.RED + message + Style.RESET_ALL
def green_message(message):
    return Fore.GREEN + message + Style.RESET_ALL
class LDAP_Vuln(Vuln_Base):
    def __init__(self, session: LDAPSession):
        super().__init__(session)
        with open('Vulnerability/LDAP_Vuln.json') as f:
            self.SIGNATURE_DATABASE = json.load(f)
        
        
        
    def scan_vulnerability(self, result_buf):
        self.session.get_naming_context()
        domain_base = self.session.domain_base
        # print(self.SIGNATURE_DATABASE['AS-REP Roasting'][0])
        for vuln_name, data in self.SIGNATURE_DATABASE.items():
            if vuln_name == 'Interesting Right':
                result_buf = self.scan_BAC(result_buf, vuln_name, data)
            elif vuln_name == 'DC Sync Attack':
                result_buf = self.scan_DCSync(result_buf, vuln_name, data)
            elif vuln_name == 'User Not Change Password':
                result_buf = self.scan_pwd_vul(result_buf, vuln_name, data)
            elif vuln_name == 'Inactive User':
                result_buf = self.scan_last_logon_vul(result_buf, vuln_name, data)
            elif vuln_name == 'Unnecessary Group':
                result_buf = self.scan_inactive_group(result_buf, vuln_name, data)
            elif vuln_name == 'Bidirectional Trust':
                result_buf = self.scan_trust(result_buf, vuln_name, data)
            else:
                name = data[0]
                signature = data[1]
                ref = data[2]
                severity = data[3]
                description = data[4]
                impact = data[5]
                recommendation = data[6] 
                result = []
                print(Fore.GREEN + "\n[+] Scanning for %s" % vuln_name + Style.RESET_ALL)
                print(Fore.GREEN + "Reference: %s\n" % ref + Style.RESET_ALL)
                vuln_data = self.session.do_ldap_query(domain_base,signature, attributes=['*'])
                if len(vuln_data) > 0:
                    for obj in vuln_data:
                        result.append([str(obj.distinguishedName.value)])
                if len(result) > 0:
                    printTable(result, header=['distinguishedName'])
                    output = table(result, header=['distinguishedName'])
                    result_buf[severity][vuln_name] = {}
                    result_buf[severity][vuln_name]['name'] = name
                    result_buf[severity][vuln_name]['description'] = description.split('\n')
                    result_buf[severity][vuln_name]['impact'] = impact.split('\n')
                    result_buf[severity][vuln_name]['recommendation'] = recommendation.split('\n')
                    result_buf[severity][vuln_name]['reference'] = ref.split('\n')
                    result_buf[severity][vuln_name]['output'] = output.split('\n')                                                        
        return result_buf
        
    def scan_BAC(self, result_buf, vuln_name, data):
        name = data[0]
        signature = data[1]
        ref = data[2]
        severity = data[3]
        description = data[4]
            # print(description)
            # print(description.split('\n'))
        
        impact = data[5]
        recommendation = data[6]
        output = []
        print(Fore.GREEN + "\n[+] Scanning for Interesting Right" + Style.RESET_ALL)
        print(Fore.GREEN + "Reference: %s\n" % ref + Style.RESET_ALL)
        session = self.session
        session.get_naming_context()
        domain_base = session.domain_base
        objecttype_guid_map = session.get_objecttype()
        group_attributes = ['*']
        domains = session.getAllDomains(attributes=group_attributes, isPrinted=False)
        users = session.getAllUsers(attributes=group_attributes, isPrinted=False)
        groups = session.getAllGroups(attributes=group_attributes, isPrinted=False)
        # computer_attributes = ['ntSecurityDescriptor', 'distinguishedName']
        computers = session.getAllComputers(attributes=group_attributes, isPrinted=False)
        ous = session.getAllOUs(attributes=group_attributes, isPrinted=False)
        gpos = session.getGPOs(attributes=group_attributes, isPrinted=False)
        sid_name = session.get_sid_name_dict()
        acls = {}
        object_type = ['domain', 'user', 'group', 'computer', 'ou', 'gpo']
        interesting_right = {
            'GenericAll': "Full rights to the object (add users to a group or reset user's password)",
            'GenericWrite': "Update object's attributes (i.e logon script)",
            'WriteOwner': "Change object owner to attacker controlled user take over the object",
            'WriteDACL': "Modify object's ACEs and give attacker full control right over the object",
            'AllExtendedRights': "Ability to add user to a group or reset password",
            'ForceChangePassword': "Ability to change user's password",
            'AddSelf': "Ability to add yourself to a group"
        }
        for type in object_type:
            acls[type] = {}
        for user in users:
            ntSecurityDescriptor = user.ntSecurityDescriptor.value
            acls['user'][user.cn.value] = parse_binary_acl('user', ntSecurityDescriptor, objecttype_guid_map, sid_name)
        for group in groups:
            ntSecurityDescriptor = group.ntSecurityDescriptor.value
            acls['group'][group.cn.value] = parse_binary_acl('group', ntSecurityDescriptor, objecttype_guid_map, sid_name)
        for computer in computers:
            ntSecurityDescriptor = computer.ntSecurityDescriptor.value
            acls['computer'][computer.cn.value] = parse_binary_acl('computer', ntSecurityDescriptor, objecttype_guid_map, sid_name)
        for ou in ous:
            ntSecurityDescriptor = ou.ntSecurityDescriptor.value
            acls['ou'][ou.name.value] = parse_binary_acl('organizational-unit', ntSecurityDescriptor, objecttype_guid_map, sid_name)
        for gpo in gpos:
            ntSecurityDescriptor = gpo.ntSecurityDescriptor.value
            acls['gpo'][gpo.displayName.value] = parse_binary_acl('gpo', ntSecurityDescriptor, objecttype_guid_map, sid_name)
        for domain in domains:
            ntSecurityDescriptor = domain.ntSecurityDescriptor.value
            acls['domain'][domain.distinguishedName.value] = parse_binary_acl('domain', ntSecurityDescriptor, objecttype_guid_map, sid_name)
        for type in object_type:
            for owner, its_acl in acls[type].items():
                # print(acl)
                empty_acl = []
                for key in its_acl.keys():
                    if len(its_acl[key]) == 0:
                        empty_acl.append(key)
                # print(empty_acl)
                for key in empty_acl:
                    del its_acl[key]
        
        for i_right, right_br in interesting_right.items():
            print(Fore.GREEN + "\n[+] Scanning for %s permission: %s\n" % (i_right, right_br) + Style.RESET_ALL)
            for type in object_type:
                for owner, its_acl in acls[type].items():
                    for target, rights in its_acl.items():
                        if i_right in rights:
                            mes = f"[+] {target} has {i_right} on {get_message_prefix_by_type(type)}{owner}"
                            output.append(mes)
                            print(Fore.GREEN + f"[+] {red_message(target)} {green_message('has')} {red_message(i_right)} {green_message('on ' + get_message_prefix_by_type(type))}{red_message(owner)} "  + Style.RESET_ALL)
            output.append(' ')
        if len(output) > 0:
            result_buf[severity][vuln_name] = {}
            result_buf[severity][vuln_name]['name'] = name
            result_buf[severity][vuln_name]['description'] = description.split('\n')
            result_buf[severity][vuln_name]['impact'] = impact.split('\n')
            result_buf[severity][vuln_name]['recommendation'] = recommendation.split('\n')
            result_buf[severity][vuln_name]['reference'] = ref.split('\n')
            result_buf[severity][vuln_name]['output'] = output
        return result_buf
        
    def scan_DCSync(self, result_buf, vuln_name, data):
        name = data[0]
        signature = data[1]
        ref = data[2]
        severity = data[3]
        description = data[4]
        impact = data[5]
        recommendation = data[6]
        output = []
        print(Fore.GREEN + "\n[+] Scanning for DC Sync Attack" + Style.RESET_ALL)
        print(Fore.GREEN + "Reference: https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/dcsync\n" + Style.RESET_ALL)
        session = self.session
        session.get_naming_context()
        objecttype_guid_map = session.get_objecttype()
        group_attributes = ['*']
        domains = session.getAllDomains(attributes=group_attributes, isPrinted=False)
        sid_name = session.get_sid_name_dict()
        acls = {}
        intersting_right = ['GetChanges', 'GetChangesAll', 'GetChangesInFilteredSet']
        full_right = ['GenericAll', 'AllExtendedRights', 'WriteDacl']
        for domain in domains:
            ntSecurityDescriptor = domain.ntSecurityDescriptor.value
            acls[domain.distinguishedName.value] = parse_binary_acl('domain', ntSecurityDescriptor, objecttype_guid_map, sid_name)
        for owner, its_acl in acls.items():
            # print(acl)
                empty_acl = []
                for key in its_acl.keys():
                    if len(its_acl[key]) == 0:
                        empty_acl.append(key)
                # print(empty_acl)
                for key in empty_acl:
                    del its_acl[key]
        for owner, its_acl in acls.items():
            for target, right in its_acl.items():
                if all(elem in right for elem in intersting_right) or any(elem in right for elem in full_right):
                    mes = f"[+] {target} can perfrom DC Sync Attack on {get_message_prefix_by_type('domain')} {owner}"
                    output.append(mes)
                    print(Fore.GREEN + f"[+] {red_message(target)} {green_message('can perfrom')} {red_message('DC Sync Attack')} {green_message('on ' + get_message_prefix_by_type('domain'))}{red_message(owner)} "  + Style.RESET_ALL)
        if len(output) > 0:
            result_buf[severity][vuln_name] = {}
            result_buf[severity][vuln_name]['name'] = name
            result_buf[severity][vuln_name]['description'] = description.split('\n')
            result_buf[severity][vuln_name]['impact'] = impact.split('\n')
            result_buf[severity][vuln_name]['recommendation'] = recommendation.split('\n')
            result_buf[severity][vuln_name]['reference'] = ref.split('\n')
            result_buf[severity][vuln_name]['output'] = output
        return result_buf
            
    def scan_pwd_vul(self, result_buf, vuln_name, data):
        name = data[0]
        signature = data[1]
        ref = data[2]
        severity = data[3]
        description = data[4]
            # print(description)
            # print(description.split('\n'))
        
        impact = data[5]
        recommendation = data[6]
        output = []
        group_attributes = ['*']
        print(Fore.GREEN + "\n[+] Scanning for User Not Change Password\n" + Style.RESET_ALL)
        users = self.session.getAllUsers(isPrinted=False)
        for user in users:
            time = str(user.pwdLastSet.value)
            time_obj = datetime.fromisoformat(time[:-6])
            formatted_time = time_obj.strftime('%Y-%m-%d')
            current_time = datetime.now()
            difference = current_time - time_obj
            if difference > timedelta(days=7):
                if formatted_time!="1601-01-01":
                    output.append(self.session.disdistinguishedName2Name(str(user.distinguishedName.value)) + ": did not change password for more than 7 days. Last time password change: " + formatted_time)
                    print(self.session.disdistinguishedName2Name(str(user.distinguishedName.value)) + ": did not change password for more than 7 days. Last time password change: " + formatted_time)
                else:
                    output.append(self.session.disdistinguishedName2Name(str(user.distinguishedName.value)) + ": This user never change password")
                    print(self.session.disdistinguishedName2Name(str(user.distinguishedName.value)) + ": did not change password")
            if len(output) > 0:
                result_buf[severity][vuln_name] = {}
                result_buf[severity][vuln_name]['name'] = name
                result_buf[severity][vuln_name]['description'] = description.split('\n')
                result_buf[severity][vuln_name]['impact'] = impact.split('\n')
                result_buf[severity][vuln_name]['recommendation'] = recommendation.split('\n')
                result_buf[severity][vuln_name]['output'] = output
        return result_buf
                    
    def scan_last_logon_vul(self, result_buf, vuln_name, data):
        name = data[0]
        signature = data[1]
        ref = data[2]
        severity = data[3]
        description = data[4]
            # print(description)
            # print(description.split('\n'))
        
        impact = data[5]
        recommendation = data[6]
        output = []
        group_attributes = ['*']
        print(Fore.GREEN + "\n[+] Scanning for Inactive User\n" + Style.RESET_ALL)
        users = self.session.getAllUsers(isPrinted=False)
        for user in users:
            time = str(user.lastLogon.value)
            time_obj = datetime.fromisoformat(time[:-6])
            formatted_time = time_obj.strftime('%Y-%m-%d')
            current_time = datetime.now()
            difference = current_time - time_obj
            if difference > timedelta(days=7):
                if formatted_time!="1601-01-01":
                    output.append(self.session.disdistinguishedName2Name(str(user.distinguishedName.value)) + ": did not log in for more than 7 days. Last log in time: " + formatted_time)
                    print(self.session.disdistinguishedName2Name(str(user.distinguishedName.value)) + ": did not log in for more than 7 days. Last log in time: " + formatted_time)
                else:
                    output.append(self.session.disdistinguishedName2Name(str(user.distinguishedName.value)) + ": This user never log in")
                    print(self.session.disdistinguishedName2Name(str(user.distinguishedName.value)) + ": This user never log in")
        
        if len(output) > 0:
            result_buf[severity][vuln_name] = {}
            result_buf[severity][vuln_name]['name'] = name
            result_buf[severity][vuln_name]['description'] = description.split('\n')
            result_buf[severity][vuln_name]['impact'] = impact.split('\n')
            result_buf[severity][vuln_name]['recommendation'] = recommendation.split('\n')
            result_buf[severity][vuln_name]['output'] = output
        return result_buf
    
    def scan_inactive_group(self, result_buf, vuln_name, data):
        name = data[0]
        signature = data[1]
        ref = data[2]
        severity = data[3]
        description = data[4]
        impact = data[5]
        recommendation = data[6]
        output = []
        excluded_group = ['Domain Users', 'Domain Guests', 'Domain Computers', 'Domain Controllers']
        print(Fore.GREEN + "\n[+] Scanning for Group with no member\n" + Style.RESET_ALL)
        groups = self.session.getAllGroups(isPrinted=False)
        for group in groups:
            if str(group.member.value).strip().lower()=='none' and str(group.cn.value) not in excluded_group:
                output.append("Group " + self.session.disdistinguishedName2Name(str(group.distinguishedName.value)) + ": has no member")
                print("Group " + self.session.disdistinguishedName2Name(str(group.distinguishedName.value)) + ": has no member")
        if len(output) > 0:
            result_buf[severity][vuln_name] = {}
            result_buf[severity][vuln_name]['name'] = name
            result_buf[severity][vuln_name]['description'] = description.split('\n')
            result_buf[severity][vuln_name]['impact'] = impact.split('\n')
            result_buf[severity][vuln_name]['recommendation'] = recommendation.split('\n')
            result_buf[severity][vuln_name]['output'] = output
        return result_buf
    
    def scan_trust(self, result_buf, vuln_name, data):
        name = data[0]
        signature = data[1]
        ref = data[2]
        severity = data[3]
        description = data[4]
        impact = data[5]
        recommendation = data[6]
        result = []
        
        print(Fore.GREEN + "\n[+] Scanning for Bidirectional Trust\n" + Style.RESET_ALL)
        print(Fore.GREEN + "Reference: %s\n" % ref + Style.RESET_ALL)
        domain_base = self.session.domain_base
        vuln_data = self.session.do_ldap_query(domain_base, signature, attributes=['cn', 'trustParent', 'trustDirection', 'trustType', 'trustAttributes'])
        trust_dict = {
            'trustDirection': ['Disabled', 'Inbound', 'Outbound', 'Bidirectional'],
            'trustType': ['Windows Domain not run Active Directory',
                          'Windows Domain running Active Directory',
                          'This domain is running a non-Windows, RFC4120-compliant Kerberos distribution',
                          'Historical reference',
                          'Azure Active Directory'
                          ]
        }
        if len(vuln_data) > 0:
            for obj in vuln_data:
                result.append([str(obj.cn.value), str(obj.trustParent.value), trust_dict['trustDirection'][int(obj.trustDirection.value)], trust_dict['trustType'][int(obj.trustType.value) - 1], str(obj.trustAttributes.value)])
                
        if len(result) > 0:
            printTable(result, header=['cn', 'trustParent', 'trustDirection', 'trustType', 'trustAttributes'])
            output = table(result, header=['cn', 'trustParent', 'trustDirection', 'trustType', 'trustAttributes'])
            result_buf[severity][vuln_name] = {}
            result_buf[severity][vuln_name]['name'] = name
            result_buf[severity][vuln_name]['description'] = description.split('\n')
            result_buf[severity][vuln_name]['impact'] = impact.split('\n')
            result_buf[severity][vuln_name]['recommendation'] = recommendation.split('\n')
            result_buf[severity][vuln_name]['reference'] = ref.split('\n')
            result_buf[severity][vuln_name]['output'] = output.split('\n')
        return result_buf