from Enumeration.SecurityDescriptor import *
from io import BytesIO
from struct import unpack, pack
import re
import binascii

EXTRIGHTS_GUID_MAPPING = {
    "GetChanges": string_to_bin("1131F6AA-9C07-11D1-F79F-00C04FC2DCD2"),
    "GetChangesAll": string_to_bin("1131F6AD-9C07-11D1-F79F-00C04FC2DCD2"),
    "GetChangesInFilteredSet": string_to_bin("89e95b76-444d-4c62-991a-0facbeda640c".upper()),
    "WriteMember": string_to_bin("bf9679c0-0de6-11d0-a285-00aa003049e2".upper()),
    "UserForceChangePassword": string_to_bin("00299570-246d-11d0-a768-00aa006e0529".upper()),
    "AllowedToAct": string_to_bin("3f78c3e5-f79a-46bd-a0b8-9d18116ddc79".upper()),
    "UserAccountRestrictionsSet": string_to_bin("4c164200-20c0-11d0-a768-00aa006e0529".upper()),
}

def string_to_bin(uuid):
    # If a UUID in the 00000000000000000000000000000000 format, let's return bytes as is
    if '-' not in uuid:
        return binascii.unhexlify(uuid)

    # If a UUID in the 00000000-0000-0000-0000-000000000000 format, parse it as Variant 2 UUID
    # The first three components of the UUID are little-endian, and the last two are big-endian
    matches = re.match(r"([\dA-Fa-f]{8})-([\dA-Fa-f]{4})-([\dA-Fa-f]{4})-([\dA-Fa-f]{4})-([\dA-Fa-f]{4})([\dA-Fa-f]{8})",
                       uuid)
    (uuid1, uuid2, uuid3, uuid4, uuid5, uuid6) = [int(x, 16) for x in matches.groups()]
    uuid = pack('<LHH', uuid1, uuid2, uuid3)
    uuid += pack('>HHL', uuid4, uuid5, uuid6)
    return uuid

def bin_to_string(uuid):
    uuid1, uuid2, uuid3 = unpack('<LHH', uuid[:8])
    uuid4, uuid5, uuid6 = unpack('>HHL', uuid[8:16])
    return '%08X-%04X-%04X-%04X-%04X%08X' % (uuid1, uuid2, uuid3, uuid4, uuid5, uuid6)

def parse_binary_acl(object_type, acl, objecttype_guid_map, sid_name: dict):
    if not acl:
        return None
    sd = SecurityDescriptor(BytesIO(acl))
    
    # Parse owner
    osid = str(sd.owner_sid)
    ignoresids = ["S-1-3-0", "S-1-5-18", "S-1-5-10"]
    # Ignore Creator Owner or Local System
    result = dict()
    for ace_object in sd.dacl.aces:
        if ace_object.ace.AceType != 0x05 and ace_object.ace.AceType != 0x00:
            continue
        sid = str(ace_object.acedata.sid)
        target = sid_name.get(sid)
        if sid in ignoresids:
            continue
        if result.get(target) is None and target is not None:
            result[target] = []
        if target is not None:
            if ace_object.ace.AceType == 0x05:
                # ACCESS_ALLOWED_OBJECT_ACE
                if not ace_object.has_flag(ACE.INHERITED_ACE) and ace_object.has_flag(ACE.INHERIT_ONLY_ACE):
                    # ACE is set on this object, but only inherited
                    continue
                # Check if the ACE has restrictions on object type (inherited case)
                if ace_object.has_flag(ACE.INHERITED_ACE) \
                    and ace_object.acedata.has_flag(ACCESS_ALLOWED_OBJECT_ACE.ACE_INHERITED_OBJECT_TYPE_PRESENT):
                    # Verify if the ACE applies to this object type
                    if not ace_applies(ace_object.acedata.get_inherited_object_type().lower(), object_type, objecttype_guid_map):
                        continue
            
                mask = ace_object.acedata.mask
                
                # Check generic access masks first
                if mask.has_priv(ACCESS_MASK.GENERIC_ALL) or mask.has_priv(ACCESS_MASK.WRITE_DACL) \
                    or mask.has_priv(ACCESS_MASK.WRITE_OWNER) or mask.has_priv(ACCESS_MASK.GENERIC_WRITE):
                    # For all generic rights we should check if it applies to our object type
                    # print(ace_object.acedata, type())
                    if ace_object.acedata.has_flag(ACCESS_ALLOWED_OBJECT_ACE.ACE_OBJECT_TYPE_PRESENT) \
                        and not ace_applies(ace_object.acedata.get_object_type().lower(), object_type, objecttype_guid_map):
                        # If it does not apply, break out of the loop here in order to
                        # avoid individual rights firing later on
                        continue
                # Check from high to low, ignore lower privs which may also match the bitmask,
                # even though this shouldn't happen since we check for exact matches currently
                
                if mask.has_priv(ACCESS_MASK.GENERIC_ALL):
                    result[target].append('GenericAll')
                if mask.has_priv(ACCESS_MASK.GENERIC_WRITE):
                    result[target].append('GenericWrite')
                if mask.has_priv(ACCESS_MASK.WRITE_DACL):
                    result[target].append('WriteDacl')
                if mask.has_priv(ACCESS_MASK.WRITE_OWNER):
                    result[target].append('WriteOwner')
                
                # Property write privileges
                writeprivs = ace_object.acedata.mask.has_priv(ACCESS_MASK.ADS_RIGHT_DS_WRITE_PROP)
                if writeprivs:
                    # GenericWrite
                    if object_type in ['user', 'group', 'computer', 'gpo'] \
                        and not ace_object.acedata.has_flag(ACCESS_ALLOWED_OBJECT_ACE.ACE_OBJECT_TYPE_PRESENT):
                        result[target].append('GenericWrite')
                    if object_type == 'group' and can_write_property(ace_object, EXTRIGHTS_GUID_MAPPING['WriteMember']):
                        result[target].append('AddMember')
                    if object_type == 'computer' and can_write_property(ace_object, EXTRIGHTS_GUID_MAPPING['AllowedToAct']):
                        result[target].append('AddAllowedToAct')
                    # Property set, but ignore Domain Admins since they already have enough privileges anyway
                    if object_type == 'computer' and can_write_property(ace_object, EXTRIGHTS_GUID_MAPPING['UserAccountRestrictionsSet']) and not target.endswith('-512'):
                        result[target].append('WriteAccountRestrictions')
                        
                    # Key credential link property write rights
                    if object_type in ['user', 'computer'] and ace_object.acedata.has_flag(ACCESS_ALLOWED_OBJECT_ACE.ACE_OBJECT_TYPE_PRESENT) \
                        and 'ms-ds-key-credential-link' in objecttype_guid_map and ace_object.acedata.get_object_type().lower() == objecttype_guid_map['ms-ds-key-credential-link']:
                        result[target].append('AddKeyCredentialLink')
                    # ServicePrincipalName property write rights (exclude generic rights)
                    if object_type == 'user' and ace_object.acedata.has_flag(ACCESS_ALLOWED_OBJECT_ACE.ACE_OBJECT_TYPE_PRESENT) \
                        and ace_object.acedata.get_object_type().lower() == objecttype_guid_map['service-principal-name']:
                        result[target].append('WriteSPN')
                elif ace_object.acedata.mask.has_priv(ACCESS_MASK.ADS_RIGHT_DS_SELF):
                    # Self add
                    if object_type == 'group' and ace_object.acedata.data.ObjectType == EXTRIGHTS_GUID_MAPPING['WriteMember']:
                        result[target].append('AddSelf')
                
                # Extended rights
                control_access = ace_object.acedata.mask.has_priv(ACCESS_MASK.ADS_RIGHT_DS_CONTROL_ACCESS)
                if control_access:  
                    # All Extended
                    if object_type in ['user', 'domain', 'computer'] and not ace_object.acedata.has_flag(ACCESS_ALLOWED_OBJECT_ACE.ACE_OBJECT_TYPE_PRESENT):
                        result[target].append('AllExtendedRights')
                    # Also report all extended if no laps
                    if object_type == 'domain' and has_extended_right(ace_object, EXTRIGHTS_GUID_MAPPING['GetChanges']):
                        result[target].append('GetChanges')
                    if object_type == 'domain' and has_extended_right(ace_object, EXTRIGHTS_GUID_MAPPING['GetChangesAll']):
                        result[target].append('GetChangesAll')
                    if object_type == 'domain' and has_extended_right(ace_object, EXTRIGHTS_GUID_MAPPING['GetChangesInFilteredSet']):
                        result[target].append('GetChangesInFilteredSet')
                    if object_type == 'user' and has_extended_right(ace_object, EXTRIGHTS_GUID_MAPPING['UserForceChangePassword']):
                        result[target].append('ForceChangePassword')
        
            if ace_object.ace.AceType == 0x00:
                mask = ace_object.acedata.mask
                # ACCESS_ALLOWED_OBJECT_ACE
                if not ace_object.has_flag(ACE.INHERITED_ACE) and ace_object.has_flag(ACE.INHERIT_ONLY_ACE):
                    # ACE is set on this object, but only inherited
                    continue
                
                if mask.has_priv(ACCESS_MASK.GENERIC_ALL):
                    # Generic all includes all other rights, so skip from here
                    result[target].append('GenericAll')
                    continue
                
                if mask.has_priv(ACCESS_MASK.ADS_RIGHT_DS_WRITE_PROP):
                    # Genericwrite is only for properties, don't skip after
                    if object_type in ['user', 'group', 'computer', 'gpo']:
                        result[target].append('GenericWrite')
                
                if mask.has_priv(ACCESS_MASK.WRITE_OWNER):
                    result[target].append('WriteOwner')
                    
                # For users and domain, check extended rights
                if object_type in ['user', 'domain'] and mask.has_priv(ACCESS_MASK.ADS_RIGHT_DS_CONTROL_ACCESS):
                    result[target].append('AllExtendedRights')
                
                if object_type == 'computer' and mask.has_priv(ACCESS_MASK.ADS_RIGHT_DS_CONTROL_ACCESS) \
                    and sid != "S-1-5-32-544" and not sid.endswith('-512'):
                    result[target].append('AllExtendedRights')
                
                if mask.has_priv(ACCESS_MASK.WRITE_DACL):
                    result[target].append('WriteDacl')
                    
                # Self add, also possible ad ACCESS_ALLOWED_ACE
                if mask.has_priv(ACCESS_MASK.ADS_RIGHT_DS_SELF) and \
                    sid != "S-1-5-32-544" and not sid.endswith('-512') and not sid.endswith('-519'):
                    if object_type == 'group':
                        result[target].append('AddSelf')
            
    return result
                
def ace_applies(ace_guid, object_class, objecttype_guid_map):
    '''
    Checks if an ACE applies to this object (based on object classes).
    Note that this function assumes you already verified that InheritedObjectType is set (via the flag).
    If this is not set, the ACE applies to all object types.
    '''
    if ace_guid == objecttype_guid_map[object_class]:
        return True
    # If none of these match, the ACE does not apply to this object
    return False
def can_write_property(ace_object, binproperty):
    '''
    Checks if the access is sufficient to write to a specific property.
    This can either be because we have the right ADS_RIGHT_DS_WRITE_PROP and the correct GUID
    is set in ObjectType, or if we have the ADS_RIGHT_DS_WRITE_PROP right and the ObjectType
    is empty, in which case we can write to any property. This is documented in
    [MS-ADTS] section 5.1.3.2: https://msdn.microsoft.com/en-us/library/cc223511.aspx
    '''
    if not ace_object.acedata.mask.has_priv(ACCESS_MASK.ADS_RIGHT_DS_WRITE_PROP):
        return False
    if not ace_object.acedata.has_flag(ACCESS_ALLOWED_OBJECT_ACE.ACE_OBJECT_TYPE_PRESENT):
        # No ObjectType present - we have generic access on all properties
        return True
    # Both are binary here
    if ace_object.acedata.data.ObjectType == binproperty:
        return True
    return False

def has_extended_right(ace_object, binrightguid):
    '''
    Checks if the access is sufficient to control the right with the given GUID.
    This can either be because we have the right ADS_RIGHT_DS_CONTROL_ACCESS and the correct GUID
    is set in ObjectType, or if we have the ADS_RIGHT_DS_CONTROL_ACCESS right and the ObjectType
    is empty, in which case we have all extended rights. This is documented in
    [MS-ADTS] section 5.1.3.2: https://msdn.microsoft.com/en-us/library/cc223511.aspx
    '''
    if not ace_object.acedata.mask.has_priv(ACCESS_MASK.ADS_RIGHT_DS_CONTROL_ACCESS):
        return False
    if not ace_object.acedata.has_flag(ACCESS_ALLOWED_OBJECT_ACE.ACE_OBJECT_TYPE_PRESENT):
        # No ObjectType present - we have all extended rights
        return True
    # Both are binary here
    if ace_object.acedata.data.ObjectType == binrightguid:
        return True
    return False